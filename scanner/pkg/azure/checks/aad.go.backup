package checks

import (
    "context"
    "fmt"
    "strings"
    "time"
    
    "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/authorization/armauthorization"
)

type AADChecks struct {
    roleClient    *armauthorization.RoleAssignmentsClient
    roleDefClient *armauthorization.RoleDefinitionsClient
}

func NewAADChecks(roleClient *armauthorization.RoleAssignmentsClient, roleDefClient *armauthorization.RoleDefinitionsClient) *AADChecks {
    return &AADChecks{
        roleClient:    roleClient,
        roleDefClient: roleDefClient,
    }
}

func (c *AADChecks) Name() string {
    return "Azure AD Security Configuration"
}

func (c *AADChecks) Run(ctx context.Context) ([]CheckResult, error) {
    results := []CheckResult{}
    
    // Note: Many Azure AD checks require Microsoft Graph API
    // These checks use ARM API which has limited AAD visibility
    
    results = append(results, c.CheckPrivilegedRoles(ctx)...)
    results = append(results, c.CheckMFAConfiguration(ctx)...)
    results = append(results, c.CheckConditionalAccess(ctx)...)
    results = append(results, c.CheckGuestAccess(ctx)...)
    
    return results, nil
}

func (c *AADChecks) CheckPrivilegedRoles(ctx context.Context) []CheckResult {
    results := []CheckResult{}
    
    // List role assignments
    pager := c.roleClient.NewListPager(nil)
    
    ownerCount := 0
    contributorCount := 0
    totalAssignments := 0
    privilegedUsers := []string{}
    
    for pager.More() {
        page, err := pager.NextPage(ctx)
        if err != nil {
            return append(results, CheckResult{
                Control:   "CC6.6",
                Name:      "Privileged Role Assignments",
                Status:    "ERROR",
                Evidence:  fmt.Sprintf("Unable to check role assignments: %v", err),
                Severity:  "HIGH",
                Priority:  PriorityHigh,
                Timestamp: time.Now(),
            })
        }
        
        for _, assignment := range page.Value {
            totalAssignments++
            
            if assignment.Properties != nil && assignment.Properties.RoleDefinitionID != nil {
                roleID := *assignment.Properties.RoleDefinitionID
                
                // Check for Owner role (8e3af657-a8ff-443c-a75c-2fe8c4bcb635)
                if strings.Contains(roleID, "8e3af657-a8ff-443c-a75c-2fe8c4bcb635") {
                    ownerCount++
                    if assignment.Properties.PrincipalID != nil {
                        privilegedUsers = append(privilegedUsers, *assignment.Properties.PrincipalID)
                    }
                }
                
                // Check for Contributor role (b24988ac-6180-42a0-ab88-20f7382dd24c)
                if strings.Contains(roleID, "b24988ac-6180-42a0-ab88-20f7382dd24c") {
                    contributorCount++
                }
            }
        }
    }
    
    // Check if too many owners (PCI DSS requires minimal privileged access)
    if ownerCount > 3 {
        results = append(results, CheckResult{
            Control:           "CC6.6",
            Name:              "Excessive Owner Assignments",
            Status:            "FAIL",
            Severity:          "HIGH",
            Evidence:          fmt.Sprintf("PCI-DSS 7.1: %d Owner role assignments found - excessive privileged access", ownerCount),
            Remediation:       "Reduce to minimum required owners (2-3 max)",
            RemediationDetail: "Azure Portal → Subscriptions → Access control (IAM) → Review Owner assignments",
            ScreenshotGuide:   "1. Go to Subscription → Access control\n2. Filter by 'Owner' role\n3. Screenshot showing minimal owners\n4. For PCI: Document why each owner needs access",
            ConsoleURL:        "https://portal.azure.com/#blade/Microsoft_Azure_Billing/SubscriptionsBlade",
            Priority:          PriorityHigh,
            Timestamp:         time.Now(),
            Frameworks: map[string]string{
                "SOC2":    "CC6.6",
                "PCI-DSS": "7.1, 7.1.2",
                "HIPAA":   "164.308(a)(4)",
            },
        })
    } else if ownerCount > 0 {
        results = append(results, CheckResult{
            Control:   "CC6.6",
            Name:      "Owner Role Assignments",
            Status:    "PASS",
            Evidence:  fmt.Sprintf("%d Owner assignments (acceptable)", ownerCount),
            Priority:  PriorityInfo,
            Timestamp: time.Now(),
            Frameworks: map[string]string{
                "SOC2":    "CC6.6",
                "PCI-DSS": "7.1",
            },
        })
    }
    
    // Check contributor assignments
    if contributorCount > 10 {
        results = append(results, CheckResult{
            Control:           "CC6.7",
            Name:              "Contributor Role Assignments",
            Status:            "FAIL",
            Severity:          "MEDIUM",
            Evidence:          fmt.Sprintf("%d Contributor assignments - review for least privilege", contributorCount),
            Remediation:       "Use more specific roles instead of Contributor",
            RemediationDetail: "Replace Contributor with specific roles like 'Virtual Machine Contributor'",
            Priority:          PriorityMedium,
            Timestamp:         time.Now(),
        })
    }
    
    return results
}

func (c *AADChecks) CheckMFAConfiguration(ctx context.Context) []CheckResult {
    results := []CheckResult{}
    
    // Note: MFA status requires Microsoft Graph API
    // This is a placeholder check that reminds users to verify
    
    results = append(results, CheckResult{
        Control:           "CC6.6",
        Name:              "Azure AD MFA for Administrators",
        Status:            "INFO",
        Evidence:          "MANUAL CHECK REQUIRED: Verify MFA is enabled for all admin accounts",
        Remediation:       "Enable MFA for all privileged accounts",
        RemediationDetail: "Azure AD → Users → Per-user MFA OR use Conditional Access policies",
        ScreenshotGuide:   "1. Azure AD → Users\n2. Click 'Per-user MFA'\n3. Screenshot showing all admins = 'Enabled' or 'Enforced'\n4. For PCI DSS 8.3.1: MFA required for ALL console access",
        ConsoleURL:        "https://portal.azure.com/#blade/Microsoft_AAD_IAM/UsersManagementMenuBlade",
        Priority:          PriorityCritical,
        Timestamp:         time.Now(),
        Frameworks: map[string]string{
            "SOC2":    "CC6.6",
            "PCI-DSS": "8.3.1",
            "HIPAA":   "164.312(a)(2)(i)",
        },
    })
    
    return results
}

func (c *AADChecks) CheckConditionalAccess(ctx context.Context) []CheckResult {
    results := []CheckResult{}
    
    // Conditional Access requires Azure AD Premium and Graph API
    results = append(results, CheckResult{
        Control:           "CC6.7",
        Name:              "Conditional Access Policies",
        Status:            "INFO",
        Evidence:          "MANUAL CHECK: Verify Conditional Access policies are configured",
        Remediation:       "Configure Conditional Access for risk-based authentication",
        RemediationDetail: "Azure AD → Security → Conditional Access → Create policies for:\n1. Require MFA for admins\n2. Block legacy authentication\n3. Require compliant devices",
        ScreenshotGuide:   "Azure AD → Security → Conditional Access → Show active policies",
        ConsoleURL:        "https://portal.azure.com/#blade/Microsoft_AAD_ConditionalAccess/ConditionalAccessBlade",
        Priority:          PriorityHigh,
        Timestamp:         time.Now(),
        Frameworks:        GetFrameworkMappings("AAD_CONDITIONAL_ACCESS"),
    })
    
    // Password policy check (requires Graph API for full details)
    results = append(results, CheckResult{
        Control:           "CC6.7",
        Name:              "Password Policy Configuration",
        Status:            "INFO",
        Evidence:          "PCI-DSS 8.2.3-8.2.5: Verify password policy meets requirements",
        Remediation:       "Configure password policy for complexity and rotation",
        RemediationDetail: "For PCI: Min 7 chars, complexity, 90-day rotation, 4 password history",
        ScreenshotGuide:   "Azure AD → Security → Authentication methods → Password protection",
        ConsoleURL:        "https://portal.azure.com/#blade/Microsoft_AAD_IAM/AuthenticationMethodsMenuBlade",
        Priority:          PriorityHigh,
        Timestamp:         time.Now(),
        Frameworks: map[string]string{
            "PCI-DSS": "8.2.3, 8.2.4, 8.2.5",
        },
    })
    
    return results
}

func (c *AADChecks) CheckGuestAccess(ctx context.Context) []CheckResult {
    results := []CheckResult{}
    
    // Check for guest/external user access
    pager := c.roleClient.NewListPager(nil)
    
    guestAssignments := 0
    
    for pager.More() {
        page, err := pager.NextPage(ctx)
        if err != nil {
            break
        }
        
        for _, assignment := range page.Value {
// //             if assignment.Properties != nil && assignment.Properties.PrincipalType != nil {
// //                 if *assignment.Properties.PrincipalType == armauthorization.PrincipalTypeUser {
                    // Check if this might be a guest user
                    // Note: Full guest detection requires Graph API
                    if assignment.Properties.PrincipalID != nil {
                        principalID := *assignment.Properties.PrincipalID
                        // Simple heuristic: guests often have different ID patterns
                        if strings.Contains(principalID, "#EXT#") {
                            guestAssignments++
                        }
                    }
                }
            }
        }
    }
    
    if guestAssignments > 0 {
        results = append(results, CheckResult{
            Control:           "CC6.1",
            Name:              "Guest User Access",
            Status:            "INFO",
            Evidence:          fmt.Sprintf("Found %d potential guest assignments - verify these are authorized", guestAssignments),
            Remediation:       "Review and restrict guest access to minimum required",
            RemediationDetail: "Azure AD → Users → Filter by 'Guest users' → Review permissions",
            Priority:          PriorityMedium,
            Timestamp:         time.Now(),
        })
    } else {
        results = append(results, CheckResult{
            Control:   "CC6.1",
            Name:      "Guest User Access",
            Status:    "PASS",
            Evidence:  "No guest user role assignments detected",
            Priority:  PriorityInfo,
            Timestamp: time.Now(),
        })
    }
    
    // Service Principal check
    servicePrincipalCount := 0
    for pager.More() {
        page, err := pager.NextPage(ctx)
        if err != nil {
            break
        }
        
        for _, assignment := range page.Value {
// //             if assignment.Properties != nil && assignment.Properties.PrincipalType != nil {
// //                 if *assignment.Properties.PrincipalType == armauthorization.PrincipalTypeServicePrincipal {
                    servicePrincipalCount++
                }
            }
        }
    }
    
    if servicePrincipalCount > 20 {
        results = append(results, CheckResult{
            Control:           "CC6.8",
            Name:              "Service Principal Proliferation",
            Status:            "FAIL",
            Severity:          "MEDIUM",
            Evidence:          fmt.Sprintf("%d service principals with role assignments - review for unused", servicePrincipalCount),
            Remediation:       "Audit and remove unused service principals",
            RemediationDetail: "Azure AD → App registrations → Review and clean up",
            Priority:          PriorityMedium,
            Timestamp:         time.Now(),
        })
    }
    
    // PCI-specific checks
    results = append(results, CheckResult{
        Control:           "PCI-8.1.8",
        Name:              "[PCI-DSS] Session Timeout Configuration",
        Status:            "INFO",
        Evidence:          "PCI-DSS 8.1.8: Verify 15-minute idle timeout is configured",
        Remediation:       "Configure session timeout in Azure AD",
        RemediationDetail: "Azure AD → Security → Conditional Access → Create policy for session timeout",
        ScreenshotGuide:   "Show Conditional Access policy with 15-minute browser session timeout",
        Priority:          PriorityMedium,
        Timestamp:         time.Now(),
        Frameworks: map[string]string{
            "PCI-DSS": "8.1.8",
        },
    })
    
    results = append(results, CheckResult{
        Control:           "PCI-8.1.4",
        Name:              "[PCI-DSS] Remove Inactive Users",
        Status:            "INFO",
        Evidence:          "PCI-DSS 8.1.4: Verify inactive users are removed within 90 days",
        Remediation:       "Review and disable inactive accounts",
        RemediationDetail: "Azure AD → Users → Sort by 'Last sign-in' → Disable after 90 days",
        ScreenshotGuide:   "Azure AD → Users → Show last sign-in dates all within 90 days",
        Priority:          PriorityHigh,
        Timestamp:         time.Now(),
        Frameworks: map[string]string{
            "PCI-DSS": "8.1.4",
        },
    })
    
    return results
}
